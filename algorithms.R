##### This script contains the main functions used in simulations #####
# It contains the implementation of our NSM algorithm in the paper, as well as
# functions generating the simulated data.


library(putils)  # installable from devtools::install_github('wangtengyao/putils')
library(InspectChangepoint)  # installable from CRAN


##### data generation #####

#' Generate a matrix of degree vectors for change point analysis
#' @param n number of time steps
#' @param N number of vertices, i.e. dimension of the problem
#' @param k number of coordinates that change
#' @param c change in value on each edge incident on a coordinate of change
#' @param tau time of change
#' @param shape shape parameter scale for beta distribution
#' @param symmetric boolean -- whether the graph is undirected
#' @param random_sign whether changes are in the same direction or random
#' @return matrix of degree vectors (columns indexed by time)
#' @details pre-change mean matrix has 0 on diag and 0.1 offdiag, post-change
#' mean matrix differ in off-diag entries of first k rows and columns, edge
#' weights generated by Beta(shape\mu, shape(1-\mu)), where \mu is the mean edge weight
#' Row sums are computed and stored in a matrix as return value.
generateData <- function(n, N, k, c, tau, shape=10, symmetric=TRUE, random_sign=FALSE, old_mean=0.1){
  # compute mean edge weight matrix before and after change
  A0 <- matrix(old_mean, N, N); diag(A0) <- 0 # mean edge weight matrix before change
  A1 <- A0
  change_edges <- outer(1:N, 1:N, function(i,j){i<=k & i<j})
  A1[change_edges] <- A0[change_edges] +
    c * sample(c(1,(-1)^random_sign), sum(change_edges), replace=TRUE)
  if (symmetric) A1[lower.tri(A1)] <- t(A1)[lower.tri(A1)]

  # generate edge weights and compute degree vectors
  if (symmetric) {
    x <- matrix(0, N, n)
    x_edge <- matrix(0, N*(N-1)/2, n)
  } else {
    x <- matrix(0, 2*N, n)
    x_edge <- matrix(0, N*(N-1), n)
  }

  for (t in 1:n){
    # generate edge weights from Beta distribution
    if (t<=tau) {mu <- A0} else {mu <- A1}
    E <- matrix(rbeta(N^2, shape*mu, shape*(1-mu)), N, N)

    if (symmetric) {
      E[lower.tri(E)] <- t(E)[lower.tri(E)]
      x[,t] <- rowSums(E)
      x_edge[,t] <- E[lower.tri(E)]
    } else {
      x[,t] <- c(rowSums(E), colSums(E)) # out-degree followed by in-degree
      x_edge[,t] <- c(E[lower.tri(E)], E[upper.tri(E)])
    }
  }
  return(list(x_deg=x, x_edge=x_edge))
}

##### implementation of the NSM algorithm #####

#' Sequential detection of change in a matrix x (assume standardised series)
#' @param x matrix
#' @param alpha error tolerance
#' @param lambda soft thresholding parameter
#' @param b consecutive close matches to have before declaring change
#' @return time of detection of change and a sequence of vectors of projections
findChange <- function(x, alpha=0.01, b=2, lambda_scale=1){
  N <- nrow(x); n <- ncol(x)
  # compute matrix of projection directions
  vhat <- matrix(NA, N, n)
  for (t in 2:n){
    lambda <- sqrt(2*log(t^2*N/alpha)) * lambda_scale
    y <- x[, 1:t, drop=F]
    y <- y / mad(y[,-1]-y[,-t]) * sqrt(2)  # normalise x by current estimate of sd
    x.cusum <- cusum.transform(y)
    if (max(abs(x.cusum)) >= lambda)
      vhat[, t] <- sparse.svd(x.cusum, lambda)
    else
      vhat[, t] <- random.UnitVector(N)
  }

  # compute consecutive sine theta distance of projections
  A <- rep(1, n)
  for (t in 3:n){
    A[t] <- sinThetaLoss(vhat[, t-1], vhat[, t])
  }

  cp <- NA
  tmp <- A < 0.5
  for (t in b:n){
    if (all(tmp[(t-b+1):t])) {cp <- t; break}
  }
  return(list(cp=cp, vhat=vhat))
}


